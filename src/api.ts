//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class ClientBase {
  /**
   * authorization token value
   */
  public token: string | undefined;

  // constructor(private authService: AuthService) {
  //   this.token = '';
  // } // @ts-ignore
  protected transformResult(url: string, response: any, processor: (response: any) => Observable<any>) {
    // console.log("transformResult added: ", url, response, processor);

    //Have to loop through each object to add the "Z" so that I can treat the incoming DateTime as UTC instead of local by default
    if (response?.data != null) {
      if (Array.isArray(response.data)) {
        response.data.forEach((item: any) => {
          Object.entries(item).forEach(([key, value]: any) => {
            //   console.log(value);
            var regex = new RegExp(/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|)/g);
            if (regex.test(value)) {
              item[key] = value + 'Z';
            }
          });
        });
      } else {
        Object.entries(response?.data).forEach(([key, value]: any) => {
          //   console.log(value);
          var regex = new RegExp(/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|)/g);
          if (regex.test(value)) {
            response.data[key] = value + 'Z';
          }
        });
      }
    }

    // console.log("transformResult new: ", url, response, processor);
    if (response.status == 401) {
      // console.log('Response 401');
      // window.location.href = '/login';
    }

    return processor(response);
  }

  async getToken(): Promise<any> {
    // return new Promise((resolve, reject) => {
    //   this.authService.getAccessTokenSilently().subscribe(res => {
    //     resolve(res);
    //   }, err => {
    //     reject(err);
    //   });
    // })
  }
  protected async transformOptions(options: any) {
    options.headers['Access-Control-Allow-Origin'] = '*';
    options.headers['Access-Control-Allow-Headers'] = 'X-Requested-With, Content-Type, Accept, Origin, Authorization';
    options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, PATCH, OPTIONS';
    options.headers['Accept'] = '*/*';
    // options.withCredentials = true;

    // var token = await this.getToken();
    // options.headers.Authorization = "Bearer " + token;

    return Promise.resolve(options);
  }
  // @ts-ignore
  protected transformResponse(data: any): Observable<any> {
    let resp;
    try {
      resp = JSON.parse(data);
    } catch (error) {
      throw Error(`[requestClient] Error parsingJSON data - ${JSON.stringify(error)}`);
    }
    if (resp.status === 'success') {
      return resp.data;
    } else {
      throw Error(`Request failed with reason -  ${data}`);
    }
  }
}

@Injectable()
export class DocumentsClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    download(licensePlateId: number, documentId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/download/{licensePlateId}/{documentId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDownload(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDownload(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    view(licensePlateId: number, documentId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/view/{licensePlateId}/{documentId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processView(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processView(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processView(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param licensePlateId (optional) 
     * @param file (optional) 
     * @return Success
     */
    addLicensePlateImage(licensePlateId: number | undefined, file: FileParameter | undefined, httpContext?: HttpContext): Observable<UploadResult> {
        let url_ = this.baseUrl + "/api/documents/add-license-plate-image?";
        if (licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' cannot be null.");
        else if (licensePlateId !== undefined)
            url_ += "licensePlateId=" + encodeURIComponent("" + licensePlateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAddLicensePlateImage(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAddLicensePlateImage(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadResult>;
        }));
    }

    protected processAddLicensePlateImage(response: HttpResponseBase): Observable<UploadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UploadClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    multiple(licensePlateId: number, files: FileParameter[] | undefined, httpContext?: HttpContext): Observable<UploadResult[]> {
        let url_ = this.baseUrl + "/api/documents/upload/multiple/{licensePlateId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processMultiple(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processMultiple(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadResult[]>;
        }));
    }

    protected processMultiple(response: HttpResponseBase): Observable<UploadResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UploadResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Sends an email with game data as json attachment
     * @param body (optional) 
     * @return Success
     */
    emailGameData(body: EmailGameDataRequest | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/game/email-game-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processEmailGameData(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processEmailGameData(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEmailGameData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all games
     * @return Success
     */
    getAll(httpContext?: HttpContext): Observable<GameModel[]> {
        let url_ = this.baseUrl + "/api/game/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GameModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all finished games
     * @return Success
     */
    getAllFinished(httpContext?: HttpContext): Observable<GameModel[]> {
        let url_ = this.baseUrl + "/api/game/get-all-finished";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllFinished(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllFinished(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel[]>;
        }));
    }

    protected processGetAllFinished(response: HttpResponseBase): Observable<GameModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get current game
     * @return Success
     */
    getCurrent(httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/get-current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetCurrent(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetCurrent(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processGetCurrent(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add license to game
     * @param body (optional) 
     * @return Success
     */
    add(body: LicenseGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAdd(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAdd(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Remove license to game
     * @param body (optional) 
     * @return Success
     */
    remove(body: LicenseGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRemove(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRemove(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create game
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update game
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete game by id
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/game/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restart game by id
     * @param id (optional) 
     * @return Success
     */
    restart(id: number | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/game/restart?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRestart(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRestart(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRestart(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ApiClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get game by id
     * @return Success
     */
    game(id: number, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGame(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGame(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processGame(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get licensePlate by id
     * @return Success
     */
    licensePlatesGet(id: number, httpContext?: HttpContext): Observable<LicensePlateModel> {
        let url_ = this.baseUrl + "/api/licensePlates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processLicensePlatesGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processLicensePlatesGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel>;
        }));
    }

    protected processLicensePlatesGet(response: HttpResponseBase): Observable<LicensePlateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicensePlateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete licensePlate by id
     * @return Success
     */
    licensePlatesDelete(id: number, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/licensePlates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processLicensePlatesDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processLicensePlatesDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processLicensePlatesDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LicensePlatesClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search for licensePlates
     * @return Success
     */
    search(query: string, httpContext?: HttpContext): Observable<LicensePlateModel[]> {
        let url_ = this.baseUrl + "/api/licensePlates/search/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<LicensePlateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LicensePlateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    view(licensePlateId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/licensePlates/view/{licensePlateId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processView(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processView(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processView(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all licensePlates
     * @return Success
     */
    getAll(httpContext?: HttpContext): Observable<LicensePlateModel[]> {
        let url_ = this.baseUrl + "/api/licensePlates/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LicensePlateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LicensePlateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create licensePlate
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLicensePlateRequest | undefined, httpContext?: HttpContext): Observable<LicensePlateModel> {
        let url_ = this.baseUrl + "/api/licensePlates/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LicensePlateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicensePlateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update licensePlate
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLicensePlateRequest | undefined, httpContext?: HttpContext): Observable<LicensePlateModel> {
        let url_ = this.baseUrl + "/api/licensePlates/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LicensePlateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicensePlateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LogClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Add log to the database
     * @param level (optional) 
     * @param body (optional) 
     * @return Success
     */
    addLog(level: LoggerLevel | undefined, body: NgxLog | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Log/AddLog?";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "level=" + encodeURIComponent("" + level) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAddLog(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAddLog(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAddLog(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SeedingClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Seed database
     * @return Success
     */
    seed(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/seeding/seed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processSeed(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSeed(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSeed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search for users by email or name
     * @return Success
     */
    search(query: string, httpContext?: HttpContext): Observable<UserModel[]> {
        let url_ = this.baseUrl + "/api/user/search/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the currently signed in user
     * @return Success
     */
    getUser(httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/get-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetUser(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetUser(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all non-deleted users
     * @return Success
     */
    getAll(httpContext?: HttpContext): Observable<UserModel[]> {
        let url_ = this.baseUrl + "/api/user/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the user by guid
     * @return Success
     */
    guid(userGUID: string, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/guid?";
        if (userGUID === undefined || userGUID === null)
            throw new Error("The parameter 'userGUID' must be defined and cannot be null.");
        else
            url_ += "userGUID=" + encodeURIComponent("" + userGUID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGuid(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGuid(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processGuid(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateRequest | undefined, httpContext?: HttpContext): Observable<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/user/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAuthenticate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAuthenticate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResponse>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateByDevice(body: AuthenticateByDeviceRequest | undefined, httpContext?: HttpContext): Observable<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/user/authenticate-by-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAuthenticateByDevice(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAuthenticateByDevice(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResponse>;
        }));
    }

    protected processAuthenticateByDevice(response: HttpResponseBase): Observable<AuthenticateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    generateSecret(deviceId: string | undefined, httpContext?: HttpContext): Observable<SecretResponse> {
        let url_ = this.baseUrl + "/api/user/generate-secret?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGenerateSecret(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGenerateSecret(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecretResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecretResponse>;
        }));
    }

    protected processGenerateSecret(response: HttpResponseBase): Observable<SecretResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refreshToken(body: RefreshTokenRequest | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/user/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRefreshToken(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRefreshToken(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    revokeToken(body: RevokeTokenRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/revoke-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRevokeToken(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRevokeToken(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processRevokeToken(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    refreshTokens(id: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/user/refresh-tokens/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRefreshTokens(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRefreshTokens(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshTokens(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRegister(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRegister(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyEmail(body: VerifyEmailRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/verify-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processVerifyEmail(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processVerifyEmail(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processVerifyEmail(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    requestEditAccess(httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/request-edit-access";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRequestEditAccess(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRequestEditAccess(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processRequestEditAccess(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body: ForgotPasswordRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processForgotPassword(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processForgotPassword(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateResetToken(body: ValidateResetTokenRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/validate-reset-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processValidateResetToken(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processValidateResetToken(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processValidateResetToken(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processResetPassword(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processResetPassword(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserRequest | undefined, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateUserRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    deleteCurrentUser(httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/delete-current-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteCurrentUser(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteCurrentUser(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processDeleteCurrentUser(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteByUserId(body: UserId | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/delete-by-user-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteByUserId(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteByUserId(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processDeleteByUserId(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    promote(userId: number, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/promote/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processPromote(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPromote(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processPromote(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    demote(userId: number, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/demote/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDemote(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDemote(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processDemote(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthenticateByDeviceRequest implements IAuthenticateByDeviceRequest {
    deviceId!: string;
    secret!: string;

    constructor(data?: IAuthenticateByDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.secret = _data["secret"];
        }
    }

    static fromJS(data: any): AuthenticateByDeviceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateByDeviceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["secret"] = this.secret;
        return data;
    }

    clone(): AuthenticateByDeviceRequest {
        const json = this.toJSON();
        let result = new AuthenticateByDeviceRequest();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateByDeviceRequest {
    deviceId: string;
    secret: string;
}

export class AuthenticateRequest implements IAuthenticateRequest {
    email!: string;
    password!: string;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }

    clone(): AuthenticateRequest {
        const json = this.toJSON();
        let result = new AuthenticateRequest();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateRequest {
    email: string;
    password: string;
}

export class AuthenticateResponse implements IAuthenticateResponse {
    userId?: UserId;
    name?: string | undefined;
    email?: string | undefined;
    role?: Role;
    isVerified?: boolean;
    requestedAccess?: boolean;
    token?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: IAuthenticateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] ? UserId.fromJS(_data["userId"]) : <any>undefined;
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            this.isVerified = _data["isVerified"];
            this.requestedAccess = _data["requestedAccess"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId ? this.userId.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isVerified"] = this.isVerified;
        data["requestedAccess"] = this.requestedAccess;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data;
    }

    clone(): AuthenticateResponse {
        const json = this.toJSON();
        let result = new AuthenticateResponse();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResponse {
    userId?: UserId;
    name?: string | undefined;
    email?: string | undefined;
    role?: Role;
    isVerified?: boolean;
    requestedAccess?: boolean;
    token?: string | undefined;
    refreshToken?: string | undefined;
}

export class CreateGameRequest implements ICreateGameRequest {
    title?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateGameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateGameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }

    clone(): CreateGameRequest {
        const json = this.toJSON();
        let result = new CreateGameRequest();
        result.init(json);
        return result;
    }
}

export interface ICreateGameRequest {
    title?: string | undefined;
    description?: string | undefined;
}

export class CreateLicensePlateRequest implements ICreateLicensePlateRequest {
    title?: string | undefined;
    author?: string | undefined;
    description?: string | undefined;
    storage?: string | undefined;
    ingredients?: string | undefined;
    directions?: string | undefined;
    cookTime?: TimeSpan;
    prepTime?: TimeSpan;
    totalTime?: TimeSpan;
    servings?: number | undefined;
    yield?: string | undefined;
    nutrition?: string | undefined;

    constructor(data?: ICreateLicensePlateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.author = _data["author"];
            this.description = _data["description"];
            this.storage = _data["storage"];
            this.ingredients = _data["ingredients"];
            this.directions = _data["directions"];
            this.cookTime = _data["cookTime"] ? TimeSpan.fromJS(_data["cookTime"]) : <any>undefined;
            this.prepTime = _data["prepTime"] ? TimeSpan.fromJS(_data["prepTime"]) : <any>undefined;
            this.totalTime = _data["totalTime"] ? TimeSpan.fromJS(_data["totalTime"]) : <any>undefined;
            this.servings = _data["servings"];
            this.yield = _data["yield"];
            this.nutrition = _data["nutrition"];
        }
    }

    static fromJS(data: any): CreateLicensePlateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLicensePlateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["author"] = this.author;
        data["description"] = this.description;
        data["storage"] = this.storage;
        data["ingredients"] = this.ingredients;
        data["directions"] = this.directions;
        data["cookTime"] = this.cookTime ? this.cookTime.toJSON() : <any>undefined;
        data["prepTime"] = this.prepTime ? this.prepTime.toJSON() : <any>undefined;
        data["totalTime"] = this.totalTime ? this.totalTime.toJSON() : <any>undefined;
        data["servings"] = this.servings;
        data["yield"] = this.yield;
        data["nutrition"] = this.nutrition;
        return data;
    }

    clone(): CreateLicensePlateRequest {
        const json = this.toJSON();
        let result = new CreateLicensePlateRequest();
        result.init(json);
        return result;
    }
}

export interface ICreateLicensePlateRequest {
    title?: string | undefined;
    author?: string | undefined;
    description?: string | undefined;
    storage?: string | undefined;
    ingredients?: string | undefined;
    directions?: string | undefined;
    cookTime?: TimeSpan;
    prepTime?: TimeSpan;
    totalTime?: TimeSpan;
    servings?: number | undefined;
    yield?: string | undefined;
    nutrition?: string | undefined;
}

export class CreateUserRequest implements ICreateUserRequest {
    firstName!: string;
    lastName!: string;
    role!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: ICreateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.role = _data["role"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): CreateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["role"] = this.role;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }

    clone(): CreateUserRequest {
        const json = this.toJSON();
        let result = new CreateUserRequest();
        result.init(json);
        return result;
    }
}

export interface ICreateUserRequest {
    firstName: string;
    lastName: string;
    role: string;
    email: string;
    password: string;
    confirmPassword: string;
}

export class DocumentModel implements IDocumentModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    createdBy?: UserModel;
    modifiedBy?: UserModel;
    deletedBy?: UserModel;
    documentId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    description?: string | undefined;
    contentType?: string | undefined;
    byteSize?: number;
    bytes?: string | undefined;
    documentKey?: string;

    constructor(data?: IDocumentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>undefined;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? UserModel.fromJS(_data["createdBy"]) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"] ? UserModel.fromJS(_data["modifiedBy"]) : <any>undefined;
            this.deletedBy = _data["deletedBy"] ? UserModel.fromJS(_data["deletedBy"]) : <any>undefined;
            this.documentId = _data["documentId"];
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.description = _data["description"];
            this.contentType = _data["contentType"];
            this.byteSize = _data["byteSize"];
            this.bytes = _data["bytes"];
            this.documentKey = _data["documentKey"];
        }
    }

    static fromJS(data: any): DocumentModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>undefined;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy ? this.modifiedBy.toJSON() : <any>undefined;
        data["deletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["documentId"] = this.documentId;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["description"] = this.description;
        data["contentType"] = this.contentType;
        data["byteSize"] = this.byteSize;
        data["bytes"] = this.bytes;
        data["documentKey"] = this.documentKey;
        return data;
    }

    clone(): DocumentModel {
        const json = this.toJSON();
        let result = new DocumentModel();
        result.init(json);
        return result;
    }
}

export interface IDocumentModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    createdBy?: UserModel;
    modifiedBy?: UserModel;
    deletedBy?: UserModel;
    documentId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    description?: string | undefined;
    contentType?: string | undefined;
    byteSize?: number;
    bytes?: string | undefined;
    documentKey?: string;
}

export class EmailGameDataRequest implements IEmailGameDataRequest {
    email!: string;
    jsonData!: string;

    constructor(data?: IEmailGameDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.jsonData = _data["jsonData"];
        }
    }

    static fromJS(data: any): EmailGameDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmailGameDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["jsonData"] = this.jsonData;
        return data;
    }

    clone(): EmailGameDataRequest {
        const json = this.toJSON();
        let result = new EmailGameDataRequest();
        result.init(json);
        return result;
    }
}

export interface IEmailGameDataRequest {
    email: string;
    jsonData: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }

    clone(): ForgotPasswordRequest {
        const json = this.toJSON();
        let result = new ForgotPasswordRequest();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordRequest {
    email: string;
}

export class GameId implements IGameId {
    value?: number;

    constructor(data?: IGameId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GameId {
        data = typeof data === 'object' ? data : {};
        let result = new GameId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }

    clone(): GameId {
        const json = this.toJSON();
        let result = new GameId();
        result.init(json);
        return result;
    }
}

export interface IGameId {
    value?: number;
}

export class GameLicensePlateModel implements IGameLicensePlateModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    gameLicensePlateId?: number;
    licensePlate?: LicensePlateModel;
    location?: string | undefined;
    vehicleType?: VehicleType;

    constructor(data?: IGameLicensePlateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>undefined;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.gameLicensePlateId = _data["gameLicensePlateId"];
            this.licensePlate = _data["licensePlate"] ? LicensePlateModel.fromJS(_data["licensePlate"]) : <any>undefined;
            this.location = _data["location"];
            this.vehicleType = _data["vehicleType"];
        }
    }

    static fromJS(data: any): GameLicensePlateModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameLicensePlateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>undefined;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["gameLicensePlateId"] = this.gameLicensePlateId;
        data["licensePlate"] = this.licensePlate ? this.licensePlate.toJSON() : <any>undefined;
        data["location"] = this.location;
        data["vehicleType"] = this.vehicleType;
        return data;
    }

    clone(): GameLicensePlateModel {
        const json = this.toJSON();
        let result = new GameLicensePlateModel();
        result.init(json);
        return result;
    }
}

export interface IGameLicensePlateModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    gameLicensePlateId?: number;
    licensePlate?: LicensePlateModel;
    location?: string | undefined;
    vehicleType?: VehicleType;
}

export class GameModel implements IGameModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    gameId?: number;
    gameNumber?: number;
    title?: string | undefined;
    description?: string | undefined;
    licensePlates?: GameLicensePlateModel[] | undefined;
    startedDateTime?: Date | undefined;
    finishedDateTime?: Date | undefined;

    constructor(data?: IGameModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>undefined;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.gameId = _data["gameId"];
            this.gameNumber = _data["gameNumber"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["licensePlates"])) {
                this.licensePlates = [] as any;
                for (let item of _data["licensePlates"])
                    this.licensePlates!.push(GameLicensePlateModel.fromJS(item));
            }
            this.startedDateTime = _data["startedDateTime"] ? new Date(_data["startedDateTime"].toString()) : <any>undefined;
            this.finishedDateTime = _data["finishedDateTime"] ? new Date(_data["finishedDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GameModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>undefined;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["gameId"] = this.gameId;
        data["gameNumber"] = this.gameNumber;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.licensePlates)) {
            data["licensePlates"] = [];
            for (let item of this.licensePlates)
                data["licensePlates"].push(item.toJSON());
        }
        data["startedDateTime"] = this.startedDateTime ? this.startedDateTime.toISOString() : <any>undefined;
        data["finishedDateTime"] = this.finishedDateTime ? this.finishedDateTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): GameModel {
        const json = this.toJSON();
        let result = new GameModel();
        result.init(json);
        return result;
    }
}

export interface IGameModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    gameId?: number;
    gameNumber?: number;
    title?: string | undefined;
    description?: string | undefined;
    licensePlates?: GameLicensePlateModel[] | undefined;
    startedDateTime?: Date | undefined;
    finishedDateTime?: Date | undefined;
}

export class GenericResult implements IGenericResult {
    success?: boolean;
    message?: string | undefined;

    constructor(data?: IGenericResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): GenericResult {
        data = typeof data === 'object' ? data : {};
        let result = new GenericResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }

    clone(): GenericResult {
        const json = this.toJSON();
        let result = new GenericResult();
        result.init(json);
        return result;
    }
}

export interface IGenericResult {
    success?: boolean;
    message?: string | undefined;
}

export class LicenseGameRequest implements ILicenseGameRequest {
    gameId?: GameId;
    licensePlateId?: LicensePlateId;

    constructor(data?: ILicenseGameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameId = _data["gameId"] ? GameId.fromJS(_data["gameId"]) : <any>undefined;
            this.licensePlateId = _data["licensePlateId"] ? LicensePlateId.fromJS(_data["licensePlateId"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LicenseGameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LicenseGameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameId"] = this.gameId ? this.gameId.toJSON() : <any>undefined;
        data["licensePlateId"] = this.licensePlateId ? this.licensePlateId.toJSON() : <any>undefined;
        return data;
    }

    clone(): LicenseGameRequest {
        const json = this.toJSON();
        let result = new LicenseGameRequest();
        result.init(json);
        return result;
    }
}

export interface ILicenseGameRequest {
    gameId?: GameId;
    licensePlateId?: LicensePlateId;
}

export class LicensePlateId implements ILicensePlateId {
    value?: number;

    constructor(data?: ILicensePlateId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LicensePlateId {
        data = typeof data === 'object' ? data : {};
        let result = new LicensePlateId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }

    clone(): LicensePlateId {
        const json = this.toJSON();
        let result = new LicensePlateId();
        result.init(json);
        return result;
    }
}

export interface ILicensePlateId {
    value?: number;
}

export class LicensePlateModel implements ILicensePlateModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    licensePlateId?: number;
    title?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    state?: StateModel;

    constructor(data?: ILicensePlateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>undefined;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.licensePlateId = _data["licensePlateId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.state = _data["state"] ? StateModel.fromJS(_data["state"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LicensePlateModel {
        data = typeof data === 'object' ? data : {};
        let result = new LicensePlateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>undefined;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["licensePlateId"] = this.licensePlateId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["image"] = this.image;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        return data;
    }

    clone(): LicensePlateModel {
        const json = this.toJSON();
        let result = new LicensePlateModel();
        result.init(json);
        return result;
    }
}

export interface ILicensePlateModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    licensePlateId?: number;
    title?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    state?: StateModel;
}

export enum LoggerLevel {
    TRACE = "TRACE",
    DEBUG = "DEBUG",
    INFO = "INFO",
    LOG = "LOG",
    WARN = "WARN",
    ERROR = "ERROR",
    FATAL = "FATAL",
    OFF = "OFF",
}

export class NgxLog implements INgxLog {
    level?: LoggerLevel;
    timestamp?: string | undefined;
    fileName?: string | undefined;
    lineNumber?: string | undefined;
    message?: string | undefined;
    additional?: any[] | undefined;

    constructor(data?: INgxLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.timestamp = _data["timestamp"];
            this.fileName = _data["fileName"];
            this.lineNumber = _data["lineNumber"];
            this.message = _data["message"];
            if (Array.isArray(_data["additional"])) {
                this.additional = [] as any;
                for (let item of _data["additional"])
                    this.additional!.push(item);
            }
        }
    }

    static fromJS(data: any): NgxLog {
        data = typeof data === 'object' ? data : {};
        let result = new NgxLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["timestamp"] = this.timestamp;
        data["fileName"] = this.fileName;
        data["lineNumber"] = this.lineNumber;
        data["message"] = this.message;
        if (Array.isArray(this.additional)) {
            data["additional"] = [];
            for (let item of this.additional)
                data["additional"].push(item);
        }
        return data;
    }

    clone(): NgxLog {
        const json = this.toJSON();
        let result = new NgxLog();
        result.init(json);
        return result;
    }
}

export interface INgxLog {
    level?: LoggerLevel;
    timestamp?: string | undefined;
    fileName?: string | undefined;
    lineNumber?: string | undefined;
    message?: string | undefined;
    additional?: any[] | undefined;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    token?: string | undefined;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): RefreshTokenRequest {
        const json = this.toJSON();
        let result = new RefreshTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenRequest {
    token?: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    name!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;
    deviceId?: string | undefined;
    deviceToken?: string | undefined;
    timeZone?: string | undefined;
    utcOffset?: number;
    model?: string | undefined;
    manufacturer?: string | undefined;
    operatingSystem?: string | undefined;
    operatingSystemVersion?: string | undefined;
    platform?: string | undefined;
    webViewVersion?: string | undefined;
    isVirtual?: boolean;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.deviceId = _data["deviceId"];
            this.deviceToken = _data["deviceToken"];
            this.timeZone = _data["timeZone"];
            this.utcOffset = _data["utcOffset"];
            this.model = _data["model"];
            this.manufacturer = _data["manufacturer"];
            this.operatingSystem = _data["operatingSystem"];
            this.operatingSystemVersion = _data["operatingSystemVersion"];
            this.platform = _data["platform"];
            this.webViewVersion = _data["webViewVersion"];
            this.isVirtual = _data["isVirtual"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["deviceId"] = this.deviceId;
        data["deviceToken"] = this.deviceToken;
        data["timeZone"] = this.timeZone;
        data["utcOffset"] = this.utcOffset;
        data["model"] = this.model;
        data["manufacturer"] = this.manufacturer;
        data["operatingSystem"] = this.operatingSystem;
        data["operatingSystemVersion"] = this.operatingSystemVersion;
        data["platform"] = this.platform;
        data["webViewVersion"] = this.webViewVersion;
        data["isVirtual"] = this.isVirtual;
        return data;
    }

    clone(): RegisterRequest {
        const json = this.toJSON();
        let result = new RegisterRequest();
        result.init(json);
        return result;
    }
}

export interface IRegisterRequest {
    name: string;
    email: string;
    password: string;
    confirmPassword: string;
    deviceId?: string | undefined;
    deviceToken?: string | undefined;
    timeZone?: string | undefined;
    utcOffset?: number;
    model?: string | undefined;
    manufacturer?: string | undefined;
    operatingSystem?: string | undefined;
    operatingSystemVersion?: string | undefined;
    platform?: string | undefined;
    webViewVersion?: string | undefined;
    isVirtual?: boolean;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    token!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }

    clone(): ResetPasswordRequest {
        const json = this.toJSON();
        let result = new ResetPasswordRequest();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordRequest {
    token: string;
    password: string;
    confirmPassword: string;
}

export class RevokeTokenRequest implements IRevokeTokenRequest {
    token?: string | undefined;

    constructor(data?: IRevokeTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): RevokeTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): RevokeTokenRequest {
        const json = this.toJSON();
        let result = new RevokeTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IRevokeTokenRequest {
    token?: string | undefined;
}

export enum Role {
    Unknown = "Unknown",
    User = "User",
    Editor = "Editor",
    Admin = "Admin",
}

export class SecretResponse implements ISecretResponse {
    secret?: string | undefined;

    constructor(data?: ISecretResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secret = _data["secret"];
        }
    }

    static fromJS(data: any): SecretResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecretResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secret"] = this.secret;
        return data;
    }

    clone(): SecretResponse {
        const json = this.toJSON();
        let result = new SecretResponse();
        result.init(json);
        return result;
    }
}

export interface ISecretResponse {
    secret?: string | undefined;
}

export class StateModel implements IStateModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    stateId?: number;
    name?: string | undefined;
    abbreviation?: string | undefined;

    constructor(data?: IStateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>undefined;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.stateId = _data["stateId"];
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
        }
    }

    static fromJS(data: any): StateModel {
        data = typeof data === 'object' ? data : {};
        let result = new StateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>undefined;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["stateId"] = this.stateId;
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        return data;
    }

    clone(): StateModel {
        const json = this.toJSON();
        let result = new StateModel();
        result.init(json);
        return result;
    }
}

export interface IStateModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    stateId?: number;
    name?: string | undefined;
    abbreviation?: string | undefined;
}

export class TimeSpan implements ITimeSpan {
    ticks?: number;
    readonly days?: number;
    readonly hours?: number;
    readonly milliseconds?: number;
    readonly microseconds?: number;
    readonly nanoseconds?: number;
    readonly minutes?: number;
    readonly seconds?: number;
    readonly totalDays?: number;
    readonly totalHours?: number;
    readonly totalMilliseconds?: number;
    readonly totalMicroseconds?: number;
    readonly totalNanoseconds?: number;
    readonly totalMinutes?: number;
    readonly totalSeconds?: number;

    constructor(data?: ITimeSpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticks = _data["ticks"];
            (<any>this).days = _data["days"];
            (<any>this).hours = _data["hours"];
            (<any>this).milliseconds = _data["milliseconds"];
            (<any>this).microseconds = _data["microseconds"];
            (<any>this).nanoseconds = _data["nanoseconds"];
            (<any>this).minutes = _data["minutes"];
            (<any>this).seconds = _data["seconds"];
            (<any>this).totalDays = _data["totalDays"];
            (<any>this).totalHours = _data["totalHours"];
            (<any>this).totalMilliseconds = _data["totalMilliseconds"];
            (<any>this).totalMicroseconds = _data["totalMicroseconds"];
            (<any>this).totalNanoseconds = _data["totalNanoseconds"];
            (<any>this).totalMinutes = _data["totalMinutes"];
            (<any>this).totalSeconds = _data["totalSeconds"];
        }
    }

    static fromJS(data: any): TimeSpan {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticks"] = this.ticks;
        data["days"] = this.days;
        data["hours"] = this.hours;
        data["milliseconds"] = this.milliseconds;
        data["microseconds"] = this.microseconds;
        data["nanoseconds"] = this.nanoseconds;
        data["minutes"] = this.minutes;
        data["seconds"] = this.seconds;
        data["totalDays"] = this.totalDays;
        data["totalHours"] = this.totalHours;
        data["totalMilliseconds"] = this.totalMilliseconds;
        data["totalMicroseconds"] = this.totalMicroseconds;
        data["totalNanoseconds"] = this.totalNanoseconds;
        data["totalMinutes"] = this.totalMinutes;
        data["totalSeconds"] = this.totalSeconds;
        return data;
    }

    clone(): TimeSpan {
        const json = this.toJSON();
        let result = new TimeSpan();
        result.init(json);
        return result;
    }
}

export interface ITimeSpan {
    ticks?: number;
    days?: number;
    hours?: number;
    milliseconds?: number;
    microseconds?: number;
    nanoseconds?: number;
    minutes?: number;
    seconds?: number;
    totalDays?: number;
    totalHours?: number;
    totalMilliseconds?: number;
    totalMicroseconds?: number;
    totalNanoseconds?: number;
    totalMinutes?: number;
    totalSeconds?: number;
}

export class UpdateGameRequest implements IUpdateGameRequest {
    gameId?: GameId;
    title?: string | undefined;
    description?: string | undefined;
    licensePlatesToDelete?: LicensePlateModel[] | undefined;

    constructor(data?: IUpdateGameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameId = _data["gameId"] ? GameId.fromJS(_data["gameId"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["licensePlatesToDelete"])) {
                this.licensePlatesToDelete = [] as any;
                for (let item of _data["licensePlatesToDelete"])
                    this.licensePlatesToDelete!.push(LicensePlateModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateGameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameId"] = this.gameId ? this.gameId.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.licensePlatesToDelete)) {
            data["licensePlatesToDelete"] = [];
            for (let item of this.licensePlatesToDelete)
                data["licensePlatesToDelete"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateGameRequest {
        const json = this.toJSON();
        let result = new UpdateGameRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateGameRequest {
    gameId?: GameId;
    title?: string | undefined;
    description?: string | undefined;
    licensePlatesToDelete?: LicensePlateModel[] | undefined;
}

export class UpdateLicensePlateRequest implements IUpdateLicensePlateRequest {
    id?: LicensePlateId;
    title?: string | undefined;
    author?: string | undefined;
    description?: string | undefined;
    storage?: string | undefined;
    ingredients?: string | undefined;
    directions?: string | undefined;
    cookTime?: TimeSpan;
    prepTime?: TimeSpan;
    totalTime?: TimeSpan;
    servings?: number | undefined;
    yield?: string | undefined;
    nutrition?: string | undefined;
    documentsToDelete?: DocumentModel[] | undefined;

    constructor(data?: IUpdateLicensePlateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] ? LicensePlateId.fromJS(_data["id"]) : <any>undefined;
            this.title = _data["title"];
            this.author = _data["author"];
            this.description = _data["description"];
            this.storage = _data["storage"];
            this.ingredients = _data["ingredients"];
            this.directions = _data["directions"];
            this.cookTime = _data["cookTime"] ? TimeSpan.fromJS(_data["cookTime"]) : <any>undefined;
            this.prepTime = _data["prepTime"] ? TimeSpan.fromJS(_data["prepTime"]) : <any>undefined;
            this.totalTime = _data["totalTime"] ? TimeSpan.fromJS(_data["totalTime"]) : <any>undefined;
            this.servings = _data["servings"];
            this.yield = _data["yield"];
            this.nutrition = _data["nutrition"];
            if (Array.isArray(_data["documentsToDelete"])) {
                this.documentsToDelete = [] as any;
                for (let item of _data["documentsToDelete"])
                    this.documentsToDelete!.push(DocumentModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateLicensePlateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLicensePlateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id ? this.id.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["author"] = this.author;
        data["description"] = this.description;
        data["storage"] = this.storage;
        data["ingredients"] = this.ingredients;
        data["directions"] = this.directions;
        data["cookTime"] = this.cookTime ? this.cookTime.toJSON() : <any>undefined;
        data["prepTime"] = this.prepTime ? this.prepTime.toJSON() : <any>undefined;
        data["totalTime"] = this.totalTime ? this.totalTime.toJSON() : <any>undefined;
        data["servings"] = this.servings;
        data["yield"] = this.yield;
        data["nutrition"] = this.nutrition;
        if (Array.isArray(this.documentsToDelete)) {
            data["documentsToDelete"] = [];
            for (let item of this.documentsToDelete)
                data["documentsToDelete"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateLicensePlateRequest {
        const json = this.toJSON();
        let result = new UpdateLicensePlateRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateLicensePlateRequest {
    id?: LicensePlateId;
    title?: string | undefined;
    author?: string | undefined;
    description?: string | undefined;
    storage?: string | undefined;
    ingredients?: string | undefined;
    directions?: string | undefined;
    cookTime?: TimeSpan;
    prepTime?: TimeSpan;
    totalTime?: TimeSpan;
    servings?: number | undefined;
    yield?: string | undefined;
    nutrition?: string | undefined;
    documentsToDelete?: DocumentModel[] | undefined;
}

export class UpdateUserRequest implements IUpdateUserRequest {
    name?: string | undefined;

    constructor(data?: IUpdateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): UpdateUserRequest {
        const json = this.toJSON();
        let result = new UpdateUserRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserRequest {
    name?: string | undefined;
}

export class UploadResult implements IUploadResult {
    uploaded?: boolean;
    fileName?: string | undefined;
    errorCode?: number | undefined;
    message?: string | undefined;

    constructor(data?: IUploadResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uploaded = _data["uploaded"];
            this.fileName = _data["fileName"];
            this.errorCode = _data["errorCode"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): UploadResult {
        data = typeof data === 'object' ? data : {};
        let result = new UploadResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uploaded"] = this.uploaded;
        data["fileName"] = this.fileName;
        data["errorCode"] = this.errorCode;
        data["message"] = this.message;
        return data;
    }

    clone(): UploadResult {
        const json = this.toJSON();
        let result = new UploadResult();
        result.init(json);
        return result;
    }
}

export interface IUploadResult {
    uploaded?: boolean;
    fileName?: string | undefined;
    errorCode?: number | undefined;
    message?: string | undefined;
}

export class UserId implements IUserId {
    value?: number;

    constructor(data?: IUserId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UserId {
        data = typeof data === 'object' ? data : {};
        let result = new UserId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }

    clone(): UserId {
        const json = this.toJSON();
        let result = new UserId();
        result.init(json);
        return result;
    }
}

export interface IUserId {
    value?: number;
}

export class UserModel implements IUserModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    userId?: UserId;
    userGUID?: string | undefined;
    lastIPAddress?: string | undefined;
    lastLogin?: Date | undefined;
    lastLogout?: Date | undefined;
    timeZone?: string | undefined;
    utcOffset?: number | undefined;
    email?: string | undefined;
    name?: string | undefined;
    role?: Role;
    requestedAccess?: boolean;
    requestedAccessExpires?: Date | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>undefined;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>undefined;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"] ? UserId.fromJS(_data["userId"]) : <any>undefined;
            this.userGUID = _data["userGUID"];
            this.lastIPAddress = _data["lastIPAddress"];
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>undefined;
            this.lastLogout = _data["lastLogout"] ? new Date(_data["lastLogout"].toString()) : <any>undefined;
            this.timeZone = _data["timeZone"];
            this.utcOffset = _data["utcOffset"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.role = _data["role"];
            this.requestedAccess = _data["requestedAccess"];
            this.requestedAccessExpires = _data["requestedAccessExpires"] ? new Date(_data["requestedAccessExpires"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>undefined;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>undefined;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId ? this.userId.toJSON() : <any>undefined;
        data["userGUID"] = this.userGUID;
        data["lastIPAddress"] = this.lastIPAddress;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>undefined;
        data["lastLogout"] = this.lastLogout ? this.lastLogout.toISOString() : <any>undefined;
        data["timeZone"] = this.timeZone;
        data["utcOffset"] = this.utcOffset;
        data["email"] = this.email;
        data["name"] = this.name;
        data["role"] = this.role;
        data["requestedAccess"] = this.requestedAccess;
        data["requestedAccessExpires"] = this.requestedAccessExpires ? this.requestedAccessExpires.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserModel {
        const json = this.toJSON();
        let result = new UserModel();
        result.init(json);
        return result;
    }
}

export interface IUserModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | undefined;
    deletedDateTime?: Date | undefined;
    userId?: UserId;
    userGUID?: string | undefined;
    lastIPAddress?: string | undefined;
    lastLogin?: Date | undefined;
    lastLogout?: Date | undefined;
    timeZone?: string | undefined;
    utcOffset?: number | undefined;
    email?: string | undefined;
    name?: string | undefined;
    role?: Role;
    requestedAccess?: boolean;
    requestedAccessExpires?: Date | undefined;
}

export class ValidateResetTokenRequest implements IValidateResetTokenRequest {
    token!: string;

    constructor(data?: IValidateResetTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ValidateResetTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateResetTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): ValidateResetTokenRequest {
        const json = this.toJSON();
        let result = new ValidateResetTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IValidateResetTokenRequest {
    token: string;
}

export enum VehicleType {
    Unknown = "Unknown",
    Car = "Car",
    Truck = "Truck",
    Other = "Other",
}

export class VerifyEmailRequest implements IVerifyEmailRequest {
    token!: string;

    constructor(data?: IVerifyEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): VerifyEmailRequest {
        const json = this.toJSON();
        let result = new VerifyEmailRequest();
        result.init(json);
        return result;
    }
}

export interface IVerifyEmailRequest {
    token: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

/**
Copyright 2023 Scott Lewis, All rights reserved.
**/
/**
 * Copyright 2023 Scott Lewis, All rights reserved.
 */